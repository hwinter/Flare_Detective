;+
; NAME:
;      pg_plotospextrum
;
; PURPOSE: 
;      plot a spectrum from an input fit-results FITS file
;
; INPUTS:
;     
;      pg_plotospextrum,fitsfile
; 
;  
; OUTPUTS:
;      none
;      
; KEYWORDS:
;      n_spec: in case of multiple spectra, choose the one to plot
;              0 or greater--> number  
;              undefined : take ifirst
;      xlog,ylog: if set to 0 inhibits the log plot (which is default)
;      psym: is ignored
;      modthick: thickness of model lines (2 is default)
;      and many others...
;
; HISTORY:
;       23-OCT-2003 pg_plotspextrum written PG
;       05-NOV-2003 made more general in scope PG
;       19-NOV-2003 improved, now works on a different concept... PG
;       12-JAN-2004 added model dependent bahviour, but only for a few
;                   selected model (not yet "general") PG
;       17-MAY-2004 added background plot capabilities (keyword
;                   bcolor) and extapar keyword PG
;       05-OCT-2004 CONVERTED TO OSPEX FITS OUTPUT RESULT AND RENAMED PG 
;       06-OCT-2004 corrected photon conversion factors, started to
;                   work on residuals
;       08-OCT-2004 fixed yrange problem w and w/o residuals
;       16-FEB-2005 converted to use a spex object as input, since it
;          is too dangerous to assume anything about the internals of the
;          FITS files generated by the software, this could change at a
;          moment notice!!!
;       11-MAR-2005 added a few options
;       24-AUG-2006 added countspace keyword
;
;
; TO_DO: 
;
;      improve documentation
;
; AUTHOR
;       Paolo Grigis, Institute for Astronomy, ETH, Zurich
;
;-

;
;example
;pg_plotospextrum,ospex_obj,yrange=[1d-3,1d6],/ystyle


PRO pg_plotospextrum_obj,osp,n_spec=n_spec_in,xlog=xlog,ylog=ylog,psym=psym $
   ,modthick=modthick,modcolor=modcolor,modstyle=modstyle,color=color $
   ,spthick=spthick,xtitle=xtitle,title=title,ytitle=ytitle,overplot=overplot $
   ,histo=histo,nodata=nodata,erebin=erebin,nrebin=nrebin,noberr=noberr $
   ,modlinestyle=modlinestyle,bcolor=bcolor,bthick=bthick,residuals=residuals $
   ,yrange=yrange,ystyle=ystyle,xstyle=xstyle,resyrange=resyrange,resthick=resthick $
   ,showmodel=showmodel,_extra=_extra,mulfactor=mulfactor,noerr=noerr $
   ,continuum=continuum,countspace=countspace,atten_state=atten_state


IF NOT exist(osp) THEN BEGIN
   print,'Please input a SPEX object!'
   RETURN
ENDIF

atten_state=fcheck(atten_state,1)


maxcomp=10
n_spec=fcheck(n_spec_in,0)
xlog=fcheck(xlog,1)
ylog=fcheck(ylog,1)
xstyle=fcheck(xstyle,0)
ystyle=fcheck(ystyle,0)
xtitle=fcheck(xtitle,'Energy (keV)')

IF NOT keyword_set(countspace) THEN BEGIN 
   ytitle=fcheck(ytitle,'Photon flux (photons s!A-1!N cm!A-2!N keV!A-1!N)')
ENDIF $
ELSE BEGIN 
   ytitle=fcheck(ytitle,'Count rate (counts s!A-1!N keV!A-1!N)')
ENDELSE


modthick=fcheck(modthick,replicate(2,maxcomp))
modcolor=fcheck(modcolor,[7,5,4,12,1,8,9,11,10])
modstyle=fcheck(modstyle,0)
modlinestyle=fcheck(modlinestyle,replicate(modstyle,maxcomp))
showmodel=fcheck(showmodel,replicate(1,maxcomp))
psym=fcheck(psym,3)
resthick=fcheck(resthick,1.)
mulfactor=fcheck(mulfactor,1.)

IF keyword_set(residuals) THEN BEGIN
   resyrange=fcheck(resyrange,[-2,2])
ENDIF

continuum=keyword_set(continuum)

;IF exist(extapar) THEN apar=extapar ELSE BEGIN
;   IF useapar THEN  apar=spst.apar ELSE apar=spst.apar_arr[*,n_spec]
;ENDELSE

fit_done=osp->get(/spex_summ_fit_done)
nfitint=n_elements(fit_done)
n_spec=n_spec >0 <(nfitint-1)

spex_summ_params=osp->get(/spex_summ_params)
apar=spex_summ_params[*,n_spec]


title=fcheck(title,strjoin(string(apar,format='(e9.2)')))

;energy binning & rebinning
energy_edges=osp->get(/spex_summ_energy) 

edge_products,energy_edges,mean=energybins,edges_2=energyedges
enbinsize=energyedges[1,*]-energyedges[0,*]



IF NOT keyword_set(nodata) THEN BEGIN



    detarea=osp->get(/spex_summ_area)

    ;fitted model
    ph_model=(osp->get(/spex_summ_ph_model))[*,n_spec]

    ;observed counts -->photons
    count_rate=(osp->get(/spex_summ_ct_rate))[*,n_spec]
    error_rate=(osp->get(/spex_summ_ct_error))[*,n_spec]
    bk_count_rate=(osp->get(/spex_summ_bk_rate))[*,n_spec]
    bk_error_rate=(osp->get(/spex_summ_bk_error))[*,n_spec]

    conversion=(osp->get(/spex_summ_conv))[*,n_spec]
    convfact=1/(conversion*detarea*enbinsize)
    phflux=count_rate*convfact
    errflux=error_rate*convfact
    bflux=bk_count_rate*convfact
    berrflux=bk_error_rate*convfact

    ;energy mask
    emask=(osp->get(/spex_summ_emask))[*,n_spec]
    emaskind=where(emask EQ 0,countemask)


    IF keyword_set(countspace) THEN BEGIN 

       phflux=count_rate/enbinsize
       errflux=error_rate/enbinsize
       bflux=bk_count_rate/enbinsize
       berrflux=bk_error_rate/enbinsize
    ENDIF

ENDIF

;------------------------------------------------


IF keyword_set(histo) THEN psym=10.

IF NOT((keyword_set(overplot)) OR (keyword_set(nodata))) THEN BEGIN 
   IF NOT keyword_set(residuals) THEN BEGIN 
      plot, energybins, phflux*mulfactor,xlog=xlog,ylog=ylog,psym=psym,color=color $
         ,title=title,xtitle=xtitle,ytitle=ytitle,xstyle=xstyle,yrange=yrange $
         ,ystyle=ystyle,_extra=_extra,/nodata
   ENDIF $
   ELSE BEGIN

      residuals=(osp->get(/spex_summ_resid))[*,n_spec];st1[n_spec].residual
;      ind=where(residuals EQ 0)
      residuals[emaskind]=!values.f_nan

      plot,energybins, phflux*mulfactor,xlog=xlog,ylog=ylog,psym=psym,color=color $
         ,yrange=yrange $
         ,title=title,xtitle=xtitle,ytitle=ytitle,/nodata,xstyle=4 $
         ,ystyle=4+ystyle,_extra=_extra

      ;get plot position in normalized coordinates
      llc=[!p.clip[0],!p.clip[1]];,/device,/to_normal)
      urc=[!p.clip[2],!p.clip[3]];,/device,/to_normal)

      newposup=[llc[0],urc[1]-2./3*(urc[1]-llc[1]),urc[0],urc[1]]
      newposdown=[llc[0],llc[1],urc[0],llc[1]+1./3*(urc[1]-llc[1])]


      plot,energybins,residuals,position=newposdown,/device,xtitle=xtitle $
          ,ytitle='Norm. Res.',xrange=xrange,_extra=_extra,/noerase $
          ,yrange=resyrange,psym=10,xlog=xlog,xstyle=xstyle+8,xticklen=0.02*2 $
          ,thick=resthick
      oplot,10^!x.crange,[0,0],linestyle=2

      plot,energybins, phflux*mulfactor,xlog=xlog,ylog=ylog,psym=psym,color=color $
         ,title=title,xtitle=' ',ytitle=ytitle,position=newposup,/device $
         ,_extra=_extra,/NOERASE,xstyle=xstyle,xtickname=replicate(' ',30) $
         ,yrange=yrange,ystyle=ystyle

   ENDELSE 
ENDIF


;parse model string...

model=osp->get(/spex_summ_fit_function);st3.fit_function
modparinfo=fit_function_query(model,/param_index)
modcomponents=strsplit(model,'+',/extract)

N=1001
emin=min(energyedges)
emax=max(energyedges)
earr=exp(findgen(N)/(N-1)*alog(emax/emin)+alog(emin))

edge_products,earr,edges_2=earr2
edge_products,earr2,mean=earrmean



n_el=n_elements(earrmean)
nmod=n_elements(modcomponents)

yspec=fltarr(nmod+1,n_el)


IF keyword_set(countspace) THEN BEGIN
   earr2=osp->get(/spex_drm_ph_edges)
   earr2cont=osp->get(/spex_drm_ct_edges)
   earrmean=0.5*(earr2[0,*]+earr2[1,*])
   yspec=fltarr(nmod+1,n_elements(earr2cont[0,*]))
 
   drm1 = osp -> getdata(class='spex_drm', this_filter=atten_state)
   ;need a more serious way to get count rate models
   ;compute models --> multiply by srm
 ;drm1 = o -> getdata(class='spex_drm', this_filter=1)
;   SPEX_DRM_CT_EDGES
;                   FLOAT     Array[2, 101]
;   SPEX_DRM_PH_EDGES
;                   FLOAT     Array[2, 111]
 

   FOR i=0,nmod-1 DO BEGIN
      IF modcomponents[i] EQ 'vth' THEN BEGIN
         yspec[i,*]=call_function('f_'+modcomponents[i],earr2, $
                                  apar[modparinfo[i,0]:modparinfo[i,1]], $
                                  continuum=continuum)##drm1
      ENDIF $ 
      ELSE $ 
         yspec[i,*]=call_function('f_'+modcomponents[i],earr2, $
                                  apar[modparinfo[i,0]:modparinfo[i,1]])##drm1
      yspec[i,*]=yspec[i,*]/enbinsize
      yspec[nmod,*]=yspec[nmod,*]+yspec[i,*]
   ENDFOR
ENDIF $
ELSE BEGIN 

FOR i=0,nmod-1 DO BEGIN
   IF modcomponents[i] EQ 'vth' THEN BEGIN
      yspec[i,*]=call_function('f_'+modcomponents[i],earr2, $
                               apar[modparinfo[i,0]:modparinfo[i,1]], $
                               continuum=continuum)
   ENDIF $ 
   ELSE $ 
   yspec[i,*]=call_function('f_'+modcomponents[i],earr2, $
      apar[modparinfo[i,0]:modparinfo[i,1]])


   yspec[nmod,*]=yspec[nmod,*]+yspec[i,*]
ENDFOR
ENDELSE

firstmodel=1
i=0


WHILE i LE nmod DO BEGIN 

IF showmodel[i] AND firstmodel THEN BEGIN
   firstmodel=0
   IF (NOT keyword_set(overplot)) AND keyword_set(nodata) THEN $
     plot,earrmean,mulfactor*yspec[i,*],color=modcolor[i],thick=modthick[i] $
         ,linestyle=modlinestyle[i],xlog=xlog,ylog=ylog,psym=psym $
         ,title=title,xtitle=xtitle,ytitle=ytitle,_extra=_extra,/nodata $
   ELSE $
     oplot,earrmean,mulfactor*yspec[i,*],color=modcolor[i],thick=modthick[i] $
         ,linestyle=modlinestyle[i]

ENDIF ELSE IF showmodel[i] THEN BEGIN 
  
   oplot,earrmean,mulfactor*yspec[i,*],color=modcolor[i],thick=modthick[i] $
      ,linestyle=modlinestyle[i]
ENDIF  

i=i+1

ENDWHILE



IF NOT keyword_set(nodata) THEN BEGIN 

;   oplot,energyedges[*, i],mulfactor*[phflux[i],phflux[i]],color=color,psym=psym
;;pg;   oplot,energybins, phflux*mulfactor,psym=psym,color=color


    IF NOT keyword_set(noerr) THEN BEGIN 

;       stop
        

;    FOR i = 0, n_elements(phflux)-1 DO $
;       oplot,energyedges[*, i],mulfactor*[phflux[i],phflux[i]],color=color,thick=spthick


eee=energyedges[*,0:14]*0
eee[0,*]=energyedges[1,[35,40,45,50,55,60,65,70,75,80,85,90,95,100,105]]
eee[1,*]=energyedges[1,[   40,45,50,55,60,65,70,75,80,85,90,95,100,105,110]]
energyedges2=[[energyedges[*,0:35]],[eee],[energyedges[*,111:*]]]
print,energyedges2

ppp=fltarr(15)
FOR i=0,14 DO ppp[i]=exp(1/6.*total(alog(phflux[35+i*5:35+i*5+5])))
phflux2=[phflux[0:35],[ppp],phflux[111:*]]

    FOR i = 0, n_elements(phflux2)-1 DO $
       oplot,energyedges2[*, i],mulfactor*[phflux2[i],phflux2[i]],color=color,thick=spthick


;    FOR i = 0, n_elements(phflux)-1 DO $
;       oplot,[energybins[i],energybins[i]],mulfactor*[phflux[i],phflux[i]+errflux[i]] $
;          ,color=color,thick=spthick

   FOR i = 0,35 DO $
       oplot,[energybins[i],energybins[i]],mulfactor*[phflux[i],phflux[i]+errflux[i]] $
          ,color=color,thick=spthick
   FOR i = 111,n_elements(phflux)-1 DO $
       oplot,[energybins[i],energybins[i]],mulfactor*[phflux[i],phflux[i]+errflux[i]] $
          ,color=color,thick=spthick
 
    
;    FOR i = 0, n_elements(phflux)-1 DO $
;       oplot,[energybins[i],energybins[i]],mulfactor*[phflux[i],(phflux[i]-errflux[i]) $
;          > (machar()).xmin],color=color,thick=spthick

    IF exist(bcolor) THEN BEGIN
       bthick=fcheck(bthick,spthick)
       berr=1-keyword_set(noberr)

    FOR i = 0, n_elements(bflux)-1 DO $
       oplot,energyedges[*, i],mulfactor*[bflux[i],bflux[i]],color=bcolor,thick=bthick

       IF berr THEN BEGIN 
          FOR i=0,n_elements(bflux)-1 DO $
             oplot,[energybins[i], energybins[i]], mulfactor*[bflux[i], bflux[i]+ $
                berrflux[i]],color=bcolor,thick=bthick
    
          FOR i=0,n_elements(bflux)-1 DO $
             oplot,[energybins[i],energybins[i]],mulfactor*[bflux[i],(bflux[i]-berrflux[i])$
                > (machar()).xmin],color=bcolor,thick=bthick
       ENDIF
      
    ENDIF

    ENDIF 

ENDIF


END



